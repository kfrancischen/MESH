{
    "docs": [
        {
            "location": "/", 
            "text": "Package MESH\n\n\nM\nultilayer \nE\nlectromagnetic \nS\nolver for \nH\neat transfer.\n\n\nA program for computing electromagnetic far-field and near-field heat transfer for periodic, layered\nstructures, developed by \nKaifeng Chen\n (\n) of the\n\nFan group\n in the Stanford Electrical Engineering Department.\n\n\nThe program is built upon C++ and wrapped with Lua (\n= 5.2), with OpenMP and MPI support. It is enabled with heat flux calculation in both far and near field for planar, grating and pattern geometries. The source code can be downloaded at \nGithub\n. This document will cover the basic ideas behind MESH, complete descriptions of the Lua API and C++ API, and a few concrete examples created either to illustrate the simple usage or to reproduce some of results from existing literatures. The documents are organized as follows:\n\n\nOverview\n\n\n\n\nEquations \n Features\n: detailed equations computed and features offered by the package.\n\n\nInstallation\n: the installation steps on different platforms and clusters.\n\n\n\n\nLua API\n\n\n\n\nBase Class\n: the base class the code is built upon.\n\n\nSimulationPlanar\n: the inherited class for planar geometries.\n\n\nSimulationGrating\n: the inherited class for 1D grating geometries.\n\n\nSimulationPattern\n: the inherited class for 2D pattern geometries.\n\n\n\n\nC++ API\n\n\n\n\nC++ classes and functions\n: the C++ interface for all the functions.\n\n\n\n\nExamples\n\n\n\n\nTutorial Example\n: a simple tutorial about setting up the inputs and running the input script.\n\n\nSingle Plane Far-field\n: example about thermal radiation to the far field.\n\n\nTwo Planes Near-field\n: example about near-field heat transfer between two planes.\n\n\nAnisotropic Material Near-field\n: example about simulations involving anisotropic material.\n\n\nIterate Over Gaps Near-field\n: example about iterating over different gaps for near-field heat transfer between two plates.\n\n\nTwo Gratings Near-field\n: example the calculation between two grating structures in the near-field regime.\n\n\nTwo Rectangle Patterns Near-field\n: example about the near-field heat transfer between two rectangle patterned structures.\n\n\nMixed Patterns Near-field\n: example about the near-field heat transfer between two structures with different kinds of patterns (rectangle and circle).\n\n\nMPI Example\n: example about how to use Lua wrapped MPI interface for fast parallelization on distributed clusters.\n\n\n\n\nOther information\n\n\n\n\nDeveloper\n: information for developers on how to contribute to MESH.\n\n\nAbout\n: information about the author, license, copyrights and contact addresses.", 
            "title": "Home"
        }, 
        {
            "location": "/#package-mesh", 
            "text": "M ultilayer  E lectromagnetic  S olver for  H eat transfer.  A program for computing electromagnetic far-field and near-field heat transfer for periodic, layered\nstructures, developed by  Kaifeng Chen  ( ) of the Fan group  in the Stanford Electrical Engineering Department.  The program is built upon C++ and wrapped with Lua ( = 5.2), with OpenMP and MPI support. It is enabled with heat flux calculation in both far and near field for planar, grating and pattern geometries. The source code can be downloaded at  Github . This document will cover the basic ideas behind MESH, complete descriptions of the Lua API and C++ API, and a few concrete examples created either to illustrate the simple usage or to reproduce some of results from existing literatures. The documents are organized as follows:", 
            "title": "Package MESH"
        }, 
        {
            "location": "/#overview", 
            "text": "Equations   Features : detailed equations computed and features offered by the package.  Installation : the installation steps on different platforms and clusters.", 
            "title": "Overview"
        }, 
        {
            "location": "/#lua-api", 
            "text": "Base Class : the base class the code is built upon.  SimulationPlanar : the inherited class for planar geometries.  SimulationGrating : the inherited class for 1D grating geometries.  SimulationPattern : the inherited class for 2D pattern geometries.", 
            "title": "Lua API"
        }, 
        {
            "location": "/#c-api", 
            "text": "C++ classes and functions : the C++ interface for all the functions.", 
            "title": "C++ API"
        }, 
        {
            "location": "/#examples", 
            "text": "Tutorial Example : a simple tutorial about setting up the inputs and running the input script.  Single Plane Far-field : example about thermal radiation to the far field.  Two Planes Near-field : example about near-field heat transfer between two planes.  Anisotropic Material Near-field : example about simulations involving anisotropic material.  Iterate Over Gaps Near-field : example about iterating over different gaps for near-field heat transfer between two plates.  Two Gratings Near-field : example the calculation between two grating structures in the near-field regime.  Two Rectangle Patterns Near-field : example about the near-field heat transfer between two rectangle patterned structures.  Mixed Patterns Near-field : example about the near-field heat transfer between two structures with different kinds of patterns (rectangle and circle).  MPI Example : example about how to use Lua wrapped MPI interface for fast parallelization on distributed clusters.", 
            "title": "Examples"
        }, 
        {
            "location": "/#other-information", 
            "text": "Developer : information for developers on how to contribute to MESH.  About : information about the author, license, copyrights and contact addresses.", 
            "title": "Other information"
        }, 
        {
            "location": "/features/", 
            "text": "Physical Quantities Computed By MESH\n\n\nBy classifying the geometries into three different categories: planar geometry where the basic components are plates, grating geometry which contains at least one layer has a grating along \nx\n direction, and patterns where at least one layer has either rectangle or circular patterns. The details about these three types are discussed below.\n\n\nIn general, the total heat transfer between bodies with temperatures \nT_1\n and \nT_2\n is written as\n\n\n\n\nP=\\int d\\omega [\\Theta(T_1, \\omega)-\\Theta(T_2,\\omega)]\\Phi(\\omega)\n\n\n\n\nwhere the quantity \n\\Phi(\\omega)\n characterize the strength of heat transfer between the two bodies involved.\n\n\nHeat transfer in planar geometries\n\n\nFor planar geometries (implemented as \nSimulationPlanar\n object),  the quantity \n\\Phi(\\omega)\n computed by integrating the \nk_x\n and \nk_y\n vector over the whole \nk\n space, i.e.\n\n\n\n\n\\Phi(\\omega)=\\int_{-\\infty}^{\\infty}dk_x\\int_{-\\infty}^{\\infty}dk_y \\Phi(k_x,k_y, \\omega)\n\n\n\n\nAnd in the case of an isotropic material in \nx\n and \ny\n direction, the above integral can be reduced to\n\n\n\n\n\\Phi(\\omega)=\\int_{0}^{\\infty}dk_{\\parallel} \\Phi(k_{\\parallel}, \\omega)\n\n\n\n\nMESH directly provides functions to compute \n\\Phi(\\omega, k_x, k_y)\n, \n\\Phi(\\omega, k_{\\parallel})\n and \n\\Phi(\\omega)\n directly.\n\n\nHeat transfer in grating geometries\n\n\nIn the case of a grating geometry (implemented as \nSimulationGrating\n object), the heat transfer rate is written as\n\n\n\n\n\\Phi(\\omega)=\\int_{-G_x/2}^{G_x/2}dk_x\\int_{-\\infty}^{\\infty}dk_y \\Phi(k_x,k_y, \\omega)\n\n\n\n\nHere again, MESH gives access to a few things\n\n\n\n\nsettings of the integral: for isotropic geometries \n\\int_{-G_x/2}^{G_x/2}\n and  \n\\int_{-\\infty}^{\\infty}\n can be reduced to twice of the integral over the positive axis.\n\n\ndirectly computation of \n\\Phi(k_x,k_y, \\omega)\n and \n\\Phi(\\omega)\n, and allows to print out \n\\Phi(k_x,k_y, \\omega)\n in the process of obtaining \n\\Phi(\\omega)\n.\n\n\n\n\nHeat transfer in pattern geometries\n\n\nIn the case of a pattern geometry (implemented as \nSimulationPattern\n object), the heat transfer rate is written as\n\n\n\n\n\\Phi(\\omega)=\\int_{-G_x/2}^{G_x/2}dk_x\\int_{-G_y/2}^{-G_y/2}dk_y \\Phi(k_x,k_y, \\omega)\n\n\n\n\nAgain similar to the grating geometries, integral settings and printing of intermediate \n\\Phi(k_x,k_y, \\omega)\n are supported. In addition, multiple different kinds of patterns can exist in one layer. However, the code now only supports a rectangle lattice. In MESH, for 2D patterns the only types of patterns supported are rectangle, circle and ellipse, and each pattern cannot partially overlap with each other. But one pattern can be fully contained inside another pattern. In addition, extending the code to non-trivial lattice and adding supports to more patterns are in principle doable.\n\n\nSupports over both scalar dielectric and tensor dielectric\n\n\nMESH also supports material whose dielectric can be scalar, diagonal, or a tensor. These three different types are encapsulated into a Union type in MESH. Currently for tensor types, MESH can only deal with the case when epsilon in the \nz\n direction can be decomposed from \nx\n and \ny\n directions, i.e.\n\n\n\n\n \\overleftrightarrow{\\epsilon}=\\begin{pmatrix}\n\\epsilon_{xx} & \\epsilon_{xy} & 0\\\\\n\\epsilon_{yx} & \\epsilon_{yy} & 0\\\\\n0 & 0 & \\epsilon_{zz}\n\\end{pmatrix}\n\n\n\n\nA Comprehensive Lua Wrapper for Users\n\n\nLua wrapper for C code is widely used because of easy implementation and high readability. For example, \nS4\n which is also an implementation of RCWA for periodic geometries, also utilizes Lua as its front. Here MESH not only gives the user basic functionalities of computing physical quantities related to heat transfer, but also allows users to directly use MPI in a lua script, so that users have better control over the simulation at run time. To show the advantages of directly revealing MPI interface to the users, a concrete example of lua MPI interface is explained in the \nexample section\n. MESH also provides a vanilla version that can be built without MPI. In that case, OpenMP is used if the system has OpenMP libraries built in.", 
            "title": "Equations & Features"
        }, 
        {
            "location": "/features/#physical-quantities-computed-by-mesh", 
            "text": "By classifying the geometries into three different categories: planar geometry where the basic components are plates, grating geometry which contains at least one layer has a grating along  x  direction, and patterns where at least one layer has either rectangle or circular patterns. The details about these three types are discussed below.  In general, the total heat transfer between bodies with temperatures  T_1  and  T_2  is written as   P=\\int d\\omega [\\Theta(T_1, \\omega)-\\Theta(T_2,\\omega)]\\Phi(\\omega)   where the quantity  \\Phi(\\omega)  characterize the strength of heat transfer between the two bodies involved.", 
            "title": "Physical Quantities Computed By MESH"
        }, 
        {
            "location": "/features/#heat-transfer-in-planar-geometries", 
            "text": "For planar geometries (implemented as  SimulationPlanar  object),  the quantity  \\Phi(\\omega)  computed by integrating the  k_x  and  k_y  vector over the whole  k  space, i.e.   \\Phi(\\omega)=\\int_{-\\infty}^{\\infty}dk_x\\int_{-\\infty}^{\\infty}dk_y \\Phi(k_x,k_y, \\omega)   And in the case of an isotropic material in  x  and  y  direction, the above integral can be reduced to   \\Phi(\\omega)=\\int_{0}^{\\infty}dk_{\\parallel} \\Phi(k_{\\parallel}, \\omega)   MESH directly provides functions to compute  \\Phi(\\omega, k_x, k_y) ,  \\Phi(\\omega, k_{\\parallel})  and  \\Phi(\\omega)  directly.", 
            "title": "Heat transfer in planar geometries"
        }, 
        {
            "location": "/features/#heat-transfer-in-grating-geometries", 
            "text": "In the case of a grating geometry (implemented as  SimulationGrating  object), the heat transfer rate is written as   \\Phi(\\omega)=\\int_{-G_x/2}^{G_x/2}dk_x\\int_{-\\infty}^{\\infty}dk_y \\Phi(k_x,k_y, \\omega)   Here again, MESH gives access to a few things   settings of the integral: for isotropic geometries  \\int_{-G_x/2}^{G_x/2}  and   \\int_{-\\infty}^{\\infty}  can be reduced to twice of the integral over the positive axis.  directly computation of  \\Phi(k_x,k_y, \\omega)  and  \\Phi(\\omega) , and allows to print out  \\Phi(k_x,k_y, \\omega)  in the process of obtaining  \\Phi(\\omega) .", 
            "title": "Heat transfer in grating geometries"
        }, 
        {
            "location": "/features/#heat-transfer-in-pattern-geometries", 
            "text": "In the case of a pattern geometry (implemented as  SimulationPattern  object), the heat transfer rate is written as   \\Phi(\\omega)=\\int_{-G_x/2}^{G_x/2}dk_x\\int_{-G_y/2}^{-G_y/2}dk_y \\Phi(k_x,k_y, \\omega)   Again similar to the grating geometries, integral settings and printing of intermediate  \\Phi(k_x,k_y, \\omega)  are supported. In addition, multiple different kinds of patterns can exist in one layer. However, the code now only supports a rectangle lattice. In MESH, for 2D patterns the only types of patterns supported are rectangle, circle and ellipse, and each pattern cannot partially overlap with each other. But one pattern can be fully contained inside another pattern. In addition, extending the code to non-trivial lattice and adding supports to more patterns are in principle doable.", 
            "title": "Heat transfer in pattern geometries"
        }, 
        {
            "location": "/features/#supports-over-both-scalar-dielectric-and-tensor-dielectric", 
            "text": "MESH also supports material whose dielectric can be scalar, diagonal, or a tensor. These three different types are encapsulated into a Union type in MESH. Currently for tensor types, MESH can only deal with the case when epsilon in the  z  direction can be decomposed from  x  and  y  directions, i.e.    \\overleftrightarrow{\\epsilon}=\\begin{pmatrix}\n\\epsilon_{xx} & \\epsilon_{xy} & 0\\\\\n\\epsilon_{yx} & \\epsilon_{yy} & 0\\\\\n0 & 0 & \\epsilon_{zz}\n\\end{pmatrix}", 
            "title": "Supports over both scalar dielectric and tensor dielectric"
        }, 
        {
            "location": "/features/#a-comprehensive-lua-wrapper-for-users", 
            "text": "Lua wrapper for C code is widely used because of easy implementation and high readability. For example,  S4  which is also an implementation of RCWA for periodic geometries, also utilizes Lua as its front. Here MESH not only gives the user basic functionalities of computing physical quantities related to heat transfer, but also allows users to directly use MPI in a lua script, so that users have better control over the simulation at run time. To show the advantages of directly revealing MPI interface to the users, a concrete example of lua MPI interface is explained in the  example section . MESH also provides a vanilla version that can be built without MPI. In that case, OpenMP is used if the system has OpenMP libraries built in.", 
            "title": "A Comprehensive Lua Wrapper for Users"
        }, 
        {
            "location": "/installation/", 
            "text": "Prerequisites\n\n\nMESH comes with two versions: one has OpenMP support if the system has OpenMP libraries; one has MPI support. Both of them require the following prerequisites:\n\n\n\n\nLapack\n and \nblas\n (or blas mutants, such as \nopenblas\n, \natlas\n, or \nmkl\n). For MacOS this is not necessary.\n\n\nLua\n version \n= 5.2 (version 5.3.x is preferred). By default it is using mkl.\n\n\n\n\nIn order to have the MPI version of MESH installed, one needs to install MPI besides the above two libraries.\n\n\nMESH can be downloaded by\n\n\ngit clone git@github.com:kfrancischen/MESH.git\n\ncd\n MESH\n\n\n\n\n\nInstallation on Linux\n\n\nIf the above libraries are installed on the system default directory, The vanilla version of MESH can be simply installed by\n\n\nmake\n\n\n\n\n\nand the MPI version can be installed by\n\n\nmake meshMPI\n\n\n\n\n\nExecutables can be found in directory \nbuild/\n. The executables are called \nmesh\n and \nmeshMPI\n.\n\n\nFor a customized installation, please change the paths for compilers in \nMakefile.Linux\n. For OpenMP support, one can add (replace \n4\n with the maximum number of cores supported by the computer)\n\n\nexport\n \nOMP_NUM_THREADS\n=\n4\n\n\n\n\n\n\nto the \n.bashrc\n file.\n\n\nInstallation on MacOS\n\n\nDefault clang compiler does not support OpenMP. One can either follow the same steps exactly the same as the installation on Linux machines (then no OpenMP is not supported), or installing gcc with OpenMP first by\n\n\nbrew install gcc --without-multilib\n\n\n\n\n\nand then change the compiles from cc and c++ in \nMakefile.Darwin\n to corresponding GNU compilers, and add \n-fopenmp\n in the \nCFLAGS\n and \nCXXFLAGS\n.\n\n\nInstallation on Windows\n\n\n//TODO, haven't tried yet\n\n\nLocation on Clusters\n\n\nThe mesh has been built on \nhera\n, \ncomet\n and \nstampede\n. The executables are in the directory\n\n\n/home/kfchen/MESH/build/\n\n\n\n\n\nOne can add this to one's own path by adding\n\n\nexport\n \nPATH\n=\n$PATH\n:/home/kfchen/MESH/build/\n\n\n\n\n\n\nin \n.bashrc\n (on stampede it is \n.profile\n for \nbash\n).\n\n\nIn addition, on \nhera\n, please add the following line to \n.bashrc\n\n\nexport\n \nLD_LIBRARY_PATH\n=\nLD_LIBRARY_PATH:/home/kfchen/mkl/mkl/lib/intel64\n\n\n\n\n\n\nOn \ncomet\n, please add the following to your job submission file\n\n\nmodule purge\nmodule load gnu\nmodule load gnutools\nmodule load mkl\nmodule load openmpi_ib\n\n\n\n\n\nand on \nstampede\n:\n\n\nmodule purge\nmodule load gcc\nmodule load mvapich2\nmodule load mkl\n\n\n\n\n\nFor a job that use more than \n24\n cores for \ncomet\n and \n16\n cores for \nstampede\n, MPI version should be used. On \nhera\n, the OpenMP version is recommended.\n\n\nInstallation on clusters (not recommended)\n\n\nIf one wants to install MESH on his/her own directory, one \nhera\n please use\n\n\nmake -f Makefile.hera\n\n\n\n\n\nOn \ncomet\n please install Lua at the same directory as MESH and type\n\n\nmodule purge\nmodule load gnu\nmodule load gnutools\nmodule load mkl\nmodule load openmpi_ib\nmake -f Makefile.comet\n\n\n\n\n\nOn \nstampede\n please install Lua at the same directory as MESH and type\n\n\nmodule purge\nmodule load gcc\nmodule load mvapich2\nmodule load mkl\nmake -f Makefile.stampede\n\n\n\n\n\nOn clusters, both OpenMP version and MPI version will be generated.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#prerequisites", 
            "text": "MESH comes with two versions: one has OpenMP support if the system has OpenMP libraries; one has MPI support. Both of them require the following prerequisites:   Lapack  and  blas  (or blas mutants, such as  openblas ,  atlas , or  mkl ). For MacOS this is not necessary.  Lua  version  = 5.2 (version 5.3.x is preferred). By default it is using mkl.   In order to have the MPI version of MESH installed, one needs to install MPI besides the above two libraries.  MESH can be downloaded by  git clone git@github.com:kfrancischen/MESH.git cd  MESH", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/installation/#installation-on-linux", 
            "text": "If the above libraries are installed on the system default directory, The vanilla version of MESH can be simply installed by  make  and the MPI version can be installed by  make meshMPI  Executables can be found in directory  build/ . The executables are called  mesh  and  meshMPI .  For a customized installation, please change the paths for compilers in  Makefile.Linux . For OpenMP support, one can add (replace  4  with the maximum number of cores supported by the computer)  export   OMP_NUM_THREADS = 4   to the  .bashrc  file.", 
            "title": "Installation on Linux"
        }, 
        {
            "location": "/installation/#installation-on-macos", 
            "text": "Default clang compiler does not support OpenMP. One can either follow the same steps exactly the same as the installation on Linux machines (then no OpenMP is not supported), or installing gcc with OpenMP first by  brew install gcc --without-multilib  and then change the compiles from cc and c++ in  Makefile.Darwin  to corresponding GNU compilers, and add  -fopenmp  in the  CFLAGS  and  CXXFLAGS .", 
            "title": "Installation on MacOS"
        }, 
        {
            "location": "/installation/#installation-on-windows", 
            "text": "//TODO, haven't tried yet", 
            "title": "Installation on Windows"
        }, 
        {
            "location": "/installation/#location-on-clusters", 
            "text": "The mesh has been built on  hera ,  comet  and  stampede . The executables are in the directory  /home/kfchen/MESH/build/  One can add this to one's own path by adding  export   PATH = $PATH :/home/kfchen/MESH/build/   in  .bashrc  (on stampede it is  .profile  for  bash ).  In addition, on  hera , please add the following line to  .bashrc  export   LD_LIBRARY_PATH = LD_LIBRARY_PATH:/home/kfchen/mkl/mkl/lib/intel64   On  comet , please add the following to your job submission file  module purge\nmodule load gnu\nmodule load gnutools\nmodule load mkl\nmodule load openmpi_ib  and on  stampede :  module purge\nmodule load gcc\nmodule load mvapich2\nmodule load mkl  For a job that use more than  24  cores for  comet  and  16  cores for  stampede , MPI version should be used. On  hera , the OpenMP version is recommended.", 
            "title": "Location on Clusters"
        }, 
        {
            "location": "/installation/#installation-on-clusters-not-recommended", 
            "text": "If one wants to install MESH on his/her own directory, one  hera  please use  make -f Makefile.hera  On  comet  please install Lua at the same directory as MESH and type  module purge\nmodule load gnu\nmodule load gnutools\nmodule load mkl\nmodule load openmpi_ib\nmake -f Makefile.comet  On  stampede  please install Lua at the same directory as MESH and type  module purge\nmodule load gcc\nmodule load mvapich2\nmodule load mkl\nmake -f Makefile.stampede  On clusters, both OpenMP version and MPI version will be generated.", 
            "title": "Installation on clusters (not recommended)"
        }, 
        {
            "location": "/LuaAPI/baseClass/", 
            "text": "MESH is written in an inheritance manner, so most of the functions in the base class can be directly accessed by subclasses. Usage of MESH involves writing a Lua script to call into various parts of MESH. Here we describe all of the MESH base class functions that can be called within the Lua environment.\n\n\nFor which functions can be called for a given geometry, please read the pages \nSimulationPlanar\n, \nSimulationGrating\n and \nSimulationPattern\n for the geometries you are simulating.\n\n\n\n\nNote\n\n\nThe base class is just a wrapper for most of the functions, but it cannot be initiated in a Lua script. The only instances that can be initiated are the classes corresponding to different dimensions.\n\n\n\n\nAddMaterial\n(\nmaterial\n \nname\n,\n \ninput\n \nfile\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nmaterial name: [string], the name of the material added to the simulation. Such name is unique and if there already exists a material with the same name, an error message will be printed out.\n\n\ninput file: [string], a file that contains the dielectric properties of the corresponding material. For scalar dielectric, the input file should be formatted as  a list of      \n\n\nomega eps_r eps_i\n  \n\nFor diagonal dielectric, the format is a list of      \n\n\nomega eps_xx_r eps_xx_i eps_yy_r eps_yy_i eps_zz_r  eps_zz_i\n  \n\nFor tensor dielectric, the format is a list of   \n\n\nomega eps_xx_r eps_xx_i eps_xy_r eps_xy_i eps_yx_r eps_yx_i eps_yy_r eps_yy_i eps_zz_r  eps_zz_i\n     \n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: The omega needs to be aligned for all the materials in the simulation.\n\n\n\n\n\n\nSetMaterial\n(\nmaterial\n \nname\n,\n \nnew\n \nepsilon\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nmaterial name: [string], the name of the material whose epsilon will be changed. This material should already exist in the simulation (by \nAddMaterial\n), otherwise an error will be printed out.\n\n\nnew epsilon: [nested table], the length equals the number of omega, and per row is the epsilon values with the same format as the input of \nAddMaterial\n function. i.e. for scalar case the length will be \n2\n, for diagonal case the length is \n6\n and for tensor case the length is \n10\n.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nAddLayer\n(\nlayer\n \nname\n,\n \nthickness\n,\n \nmaterial\n \nname\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nlayer name: [string], the name of the layer. Similarly, the names for layers are unique, and if such name already exists in the simulation, an error message will be printed out.\n\n\nthickness: [double], the thickness of the new layer in SI unit.\n\n\nmaterial name: [string], the material that is used as the background of the layer. This material should already exist in the simulation (by \nAddMaterial\n), otherwise an error message will be printed out.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: this new added layer will be placed on top of all the previous layers.\n\n\n\n\n\n\nSetLayer\n(\nlayer\n \nname\n,\n \nthickness\n,\n \nmaterial\n \nname\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nlayer name: [string], the layer whose thickness and background will be changed. Such layer needs to already exist in the simulation, otherwise an error message will be printed out.\n\n\nthickness: [double], the new thickness of the layer.\n\n\nmaterial name: [string], the material for the background of the layer. If such material does not exist, an error message will be printed out.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nSetLayerThickness\n(\nlayer\n \nname\n,\n \nthickness\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nlayer name: [string],  the layer whose thickness will be changed. Such layer needs to already exist in the simulation, otherwise an error message will be printed out.\n\n\nthickness: [double], the new thickness of the layer.\n\n\n\n\n\n\n\n\nOutput: None  \n\n\n\n\n\n\nAddLayerCopy\n(\nnew\n \nlayer\n \nname\n,\n \noriginal\n \nlayer\n \nname\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nnew layer name: [string], the new layer that is copied from the original layer.  Such name cannot already exist in the simulation, otherwise an error message will be printed out.\n\n\noriginal layer name: [string], the original layer from whom everything is copied. If this layer does not exist in the simulation, an error will be printed out.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: this function only copies the structure information, for example any pattern of the original layer, but does not copy any thermal information. For example, even the original layer is set as a source, the copied layer is still not a source. In addition, this new added layer will be placed on top of all the previous layers.\n\n\n\n\n\n\nDeleteLayer\n(\nlayer\n \nname\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nlayer name: [string], the name of the layer that will be deleted. Such layer should already be in the system, otherwise an error will be printed out.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nSetPeriodicity\n(\np1\n,\n \np2\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\np1: [double], the periodicity in \nx\n direction in SI unit.\n\n\np2: [double, optional for grating geometry], the periodicity in \ny\n direction in SI unit.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nSetGx\n(\nnGx\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nnGx: [int], the number of positive Fourier components in \nx\n direction. The total number of G in \nx\n direction is thus 2nGx + 1.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nSetGy\n(\nnGy\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nnGy: [int], the number of positive Fourier components in \ny\n direction. The total number of G in \ny\n direction is thus 2nGy + 1.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nSetSourceLayer\n(\nlayer\n \nname\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nlayer name: [string], the name of the layer that is designated as the source layer. Such layer should already exist in the system, otherwise an error will be printed out.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: a system can have more than \n1\n source layers.\n\n\n\n\n\n\nSetProbeLayer\n(\nlayer\n \nname\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nlayer name: [string], the name of the layer that is designated as the probe layer of the flux. Such layer should already exist in the system, otherwise an error will be printed out.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: a system can have only one probe layer. Setting another layer as the probe layer will overwrite the previous one. In addition, the source layer should be above all the source layers in the real geometry.\n\n\n\n\n\n\nSetThread\n(\nnthread\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nnthreads: [int], number of threads used in OpenMP.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\nNote: this function only works in an OpenMP setup.\n\n\n\n\nSetKxIntegral\n(\npoints\n,\n \nend\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\npoints: [int], number of points in the integration.\n\n\nend: [double, optional for grating and pattern geometries], the end of the integral over \nk_x\n. This end should be a normalized number with respect to \n\\omega/c\n.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: this function is essentially doing\n\n\\int_{-\\text{end}\\cdot \\omega/c}^{\\text{end}\\cdot \\omega/c}dk_x\n where the integral is evaluated as a summation of \npoints\n points. In the case when \nend\n is not given, the lower and upper bounds of the integral will be \n\\pm G_x/2\n.\n\n\n\n\n\n\nSetKyIntegral\n(\npoints\n,\n \nend\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\npoints: [int], number of points in the integration.\n\n\nend: [double, optional for pattern geometries], the end of the integral over \nk_y\n. This end should be a normalized number with respect to \n\\omega/c\n.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: this function is essentially doing\n\n\\int_{-\\text{end}\\cdot \\omega/c}^{\\text{end}\\cdot \\omega/c}dk_y\n where the integral is evaluated as a summation of \npoints\n points. In the case when \nend\n is not given, the lower and upper bounds of the integral will be \n\\pm G_y/2\n.\n\n\n\n\n\n\nSetKxIntegralSym\n(\npoints\n,\n \nend\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\npoints: [int], number of points in the integration.\n\n\nend: [double, optional for grating and pattern geometries], the end of the integral over \nk_x\n. This end should be a normalized number with respect to \n\\omega/c\n.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: this function is essentially doing\n\n2\\times \\int_{0}^{\\text{end}\\cdot \\omega/c}dk_x\n where the integral is evaluated as a summation of \npoints\n points. In the case when \nend\n is not given, the upper bound of the integral will be \nG_x/2\n.\n\n\n\n\n\n\nSetKyIntegralSym\n(\npoints\n,\n \nend\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\npoints: [int], number of points in the integration.\n\n\nend: [double, optional for pattern geometries], the end of the integral over \nk_y\n. This end should be a normalized number with respect to \n\\omega/c\n.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: this function is essentially doing\n\n2\\times \\int_{0}^{\\text{end}\\cdot \\omega/c}dk_y\n where the integral is evaluated as a summation of \npoints\n points. In the case when \nend\n is not given, the upper bound of the integral will be \nG_y/2\n.\n\n\n\n\n\n\nInitSimulation\n()\n\n\n\n\n\n\n\n\n\n\nArguments: None\n\n\n\n\n\n\nNote: this function builds up the structure of the system.\n\n\n\n\n\n\nIntegrateKxKy\n()\n\n\n\n\n\n\n\n\n\n\nArguments: None\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: this function integrates over \nk_x\n and \nk_y\n based on the integral properties set by the user. So the function can only be called after the \nk_x\n and \nk_y\n integrals are configured, and the system is initialized.\n\n\n\n\n\n\nIntegrateKxKyMPI\n(\nrank\n,\n \nsize\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nrank: [int], the rank of the thread.\n\n\nsize: [int], the total size of the MPI run.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: this function can only be called during MPI. For an example of a funtion call,  please refer to \nMPI example\n.\n\n\n\n\n\n\nGetNumOfOmega\n()\n\n\n\n\n\n\n\n\n\n\nArguments: None\n\n\n\n\n\n\nOutput: [int], the number of total omega points computed in the simulation.\n\n\n\n\n\n\nGetPhi\n()\n\n\n\n\n\n\n\n\n\n\nArguments: None\n\n\n\n\n\n\nOutput: [table of double], the \n\\Phi(\\omega)\n values obtained from the simulation.\n\n\n\n\n\n\nNote: can only be called after \nk_x\n and \nk_y\n are integrated.\n\n\n\n\n\n\nGetOmega\n()\n\n\n\n\n\n\n\n\n\n\nArguments: None\n\n\n\n\n\n\nOutput: [table of double], the omega values computed in the simulation.\n\n\n\n\n\n\nGetEpsilon\n(\nomega\n \nindex\n,\n \n{\nx\n,\n \ny\n,\n \nz\n})\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nomega index: [int], the index of the omega value where \n\\epsilon\n is evaluated.  To be consistent with Lua, this index starts from \n1\n.\n\n\n{x, y, z}: [double table], the real space position where the index is evaluated, in SI unit\n\n\n\n\n\n\n\n\nOutput: value of epsilon with length \n10\n, in the form of\n  \neps_xx_r, eps_xx_i, eps_xy_r, eps_xy_i, eps_yx_r, eps_yx_i,\u3000eps_yy_r, eps_yy_i, eps_zz_r, eps_zz_i\n\n  These are computed by reconstruction of the Fourier series, so won't be the same as the exact dielectric function.\n\n\n\n\n\n\nGetPhiAtKxKy\n(\nomega\n \nindex\n,\n \nkx\n,\n \nky\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nomega index: [int], the index of the omega value where \n\\Phi(\\omega[\\text{index}], k_x, k_y)\n is evaluated.  To be consistent with Lua, this index starts from \n1\n.\n\n\nkx: [double], the \nk_x\n value where \n\\Phi(\\omega[\\text{index}], k_x, k_y)\n is evaluated. It is a normalized value by \n\\omega[\\text{index}]/c\n.\n\n\nky: [double], the \nk_y\n value where \n\\Phi(\\omega[\\text{index}], k_x, k_y)\n is evaluated. It is a normalized value by \n\\omega[\\text{index}]/c\n.\n\n\n\n\n\n\n\n\nOutput: [double], the value of \n\\Phi(\\omega, k_x, k_y)\n.\n\n\n\n\n\n\nOutputSysInfo\n()\n\n\n\n\n\n\n\n\n\n\nArguments: None\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: the function prints out a system description to screen.\n\n\n\n\n\n\nOutputLayerPatternRealization\n(\nomega\n \nindex\n,\n \nname\n,\n \nNu\n,\n \nNv\n,\n \nfilename\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nomega index: [int], the index of the omega value that the dielectric is evaluated.   To be consistent with Lua, this index starts from \n1\n.\n\n\nname: [string], the name of the layer.\n\n\nNu: [int], number of points in x direction in one periodicity.\n\n\nNv: [int], number of points in y direction in one periodicity.\n\n\nfilename: [string], optional. If not given, then the epsilon values will be printed to standard output.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: the epsilon format will be the same as the function \nGetEpsilon\n.\n\n\n\n\n\n\nAlso, MESH provides some options for printing intermediate information and methods for Fourier transform of the dielectric.\n\n\nOptOnlyComputeTE\n()\n\n\n\n\n\n\n\n\n\n\nArguments: None\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: with this function, the package only computes flux contributed from TE mode.\n\n\n\n\n\n\nOptOnlyComputeTM\n()\n\n\n\n\n\n\n\n\n\n\nArguments: None\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: with this function, the package only computes flux contributed from TM mode.\n\n\n\n\n\n\nOptUseNaiveRule\n()\n\n\n\n\n\n\n\n\n\n\nArguments: None\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: this function tells the RCWA to use the simplest closed form Fourier transform for the dielectric.\n\n\n\n\n\n\nOptUseInverseRule\n()\n\n\n\n\n\n\n\n\n\n\nArguments: None\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: this function tells the RCWA to use the inverse rule of the Fourier transform for the dielectric. (This options is not implemented yet.)\n\n\n\n\n\n\nOptPrintIntermediate\n()\n\n\n\n\n\n\n\n\n\n\nArguments: None\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: this function prints intermediate \n\\Phi(\\omega, k_x, k_y)\n when function \nIntegrateKxKy()\n or \nIntegrateKxKyMPI(rank, size)\n is called. The output format is\na list of \"\n\\omega\n\n\nk_x\n\n\nk_y\n\n\n\\Phi(\\omega, k_x, k_y)\n\", where \nk_x\n and \nk_y\n are values normalized to \n\\omega/c\n.\n\n\n\n\n\n\n\n\nWarning\n\n\nIn MPI this function is not guaranteed to be atomic, meaning the printed output might be messed because each process is writing its own value to the screen. However for OpenMP, there is no such problem.\n\n\n\n\nMESH also provides physics constants to facilitate computation. The constant object can be initiated by\n\n\nconstant\n \n=\n \nConstants\n()\n\n\n\n\n\n\nThe supported constants are (all in SI unit)\n\n\n\n\nconstant.pi: the value of \n\\pi\n.\n\n\nconstant.k_B: the value of \nk_B\n.\n\n\nconstant.eps_0: the value of \n\\epsilon_0\n.\n\n\nconstant.mu_0: the value of \n\\mu_0\n.\n\n\nconstant.m_e: the value of \nm_e\n, i.e. the mass of an electron.\n\n\nconstant.eV: electron volt in Joules.\n\n\nconstant.h: the value of Planck's constant.\n\n\nconstant.h_bar: the value of the reduced Planck's constant.\n\n\nconstant.c_0: the speed of light.\n\n\nconstant.q: the value of \nq\n, i.e. magnitude of electron charge.\n\n\nconstant.sigma: the value of \n\\sigma\n, i.e. Stefan-Boltzmann constant.", 
            "title": "Base Class"
        }, 
        {
            "location": "/LuaAPI/planar/", 
            "text": "The SimulationPlanar class can be initiated in Lua script by\n\n\ns\n \n=\n \nSimulationPlanar\n.\nnew\n()\n\n\n\n\n\n\nMost of the function provided in \nbase class\n can be used except for the following changes.\n\n\n\n\nFailure\n\n\nThe following function are unavailable and cannot be called for a \nSimulationPlanar\n object.\n\n\n\n\nSetGx\n(\nnGx\n)\n\n\nSetGy\n(\nnGy\n)\n\n\nSetperiodicity\n(\np1\n,\n \np2\n)\n\n\nOptUseNaiveRule\n()\n\n\nOptUseInverseRule\n()\n\n\nOptPrintIntermediate\n()\n\n\n\n\n\n\n\n\nNote\n\n\nThe following functions are added and specific to \nSimulationPlanar\n object.\n\n\n\n\nSetKParallel\n(\nend\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nend: [double], the end of the \nk_{\\parallel}\n integral. It is a normalized number with respect to \n\\omega/c\n.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: this function is essentially doing\n\n \\int_{0}^{\\text{end}\\cdot\\omega/c}dk_{\\parallel}\n\nwhere the integral is evaluated either using Gauss-legendre methdod or Gauss-kronrod adaptive method.\n\n\n\n\n\n\nGetPhiAtKParallel\n(\nomega\n \nindex\n,\n \nk\n \nparallel\n \nvalue\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nomega index: [int], the index of omega where \n\\Phi(\\omega[\\text{index}], k_{\\parallel})\n is evaluated. To be consistent with Lua, this index starts from \n1\n.\n\n\nk parallel: [double], the \nk_{\\parallel}\n value where \n\\Phi(\\omega[\\text{index}], k_{\\parallel})\n is evaluated. It should be a normalized value with respect to \n\\omega[\\text{index}]/c\n.\n\n\n\n\n\n\n\n\nOutput: [double], value of \n\\Phi(\\omega[\\text{index}], k_{\\parallel})\n.\n\n\n\n\n\n\nIntegrateKParallel\n()\n\n\n\n\n\n\n\n\n\n\nArguments: None\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: before using this function, make sure the flux integral can be reduced to a \nk_{\\parallel}\n integral. In principle, the cases when all the materials possess only scalar dielectric or diagonal forms\n\n \\begin{pmatrix}\n\\epsilon_{1} & 0 & 0\\\\\n0 & \\epsilon_{1} & 0\\\\\n0 & 0 & \\epsilon_{2}\n\\end{pmatrix}\n can use this function.\n\n\n\n\n\n\nOptUseQuadgl\n(\ndegree\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\ndegree: [int, optional], using Gauss-legendre method in the integral and set the degree of legendre polynomial in \nIntegrateKParallel()\n. If degree is not given, it is set to be \n1024\n.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nOptUseQuadgk\n()\n\n\n\n\n\n\n\n\n\n\nArguments: None\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: this function uses Gauss-kronrod adaptive integral algorithm in \nIntegrateKParallel()\n. The simulation will use this function if the integral option is not specified.", 
            "title": "SimulationPlanar"
        }, 
        {
            "location": "/LuaAPI/grating/", 
            "text": "The SimulationGrating class can be initiated in Lua script by\n\n\ns\n \n=\n \nSimulationGrating\n.\nnew\n()\n\n\n\n\n\n\nAll of the function provided in \nbase class\n can be used except for the following changes.\n\n\n\n\nWarning\n\n\nThe following function needs to be called specifically for \nSimulationGrating\n object.\n\n\n\n\nSetPeriodicity\n(\np1\n)\n\n\n\n\n\n\nThe above function can only be called without the second argument \np2\n.\n\n\n\n\nNote\n\n\nThe following functions are added and specific to \nSimulationGrating\n object.\n\n\n\n\nSetLayerPatternGrating\n(\nlayer\n \nname\n,\n \nmaterial\n \nname\n,\n \ncenter\n,\n \nwidth\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nlayer name: [string], the layer that this grating will be embedded. Such layer should already exist in the simulation, otherwise an error message will be printed out.\n\n\nmaterial name: [string],  the material used as the grating. Such material should already exist in the simulation, otherwise an error message will be printed out.\n\n\ncenter: [double], the center of the grating in SI unit.\n\n\nwidth: [double], the width of the grating in SI unit.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nOptUseAdaptive\n()\n\n\n\n\n\n\n\n\n\n\nArguments: None\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: this function will use the \nspatial adaptive resolution method\n to compute the Fourier transform of the dielectric. (This option is not implemented yet).", 
            "title": "SimulationGrating"
        }, 
        {
            "location": "/LuaAPI/pattern/", 
            "text": "The SimulationPattern class can be initiated in Lua script by\n\n\ns\n \n=\n \nSimulationPattern\n.\nnew\n()\n\n\n\n\n\n\nAll of the function provided in \nbase class\n can be used.\n\n\n\n\nNote\n\n\nThe following functions are added and specific to \nSimulationPattern\n object.\n\n\n\n\nSetLayerPatternRectangle\n(\nlayer\n \nname\n,\n \nmaterial\n \nname\n,\n \n{\ncenterx\n,\n \ncentery\n},\n \n{\nwidthx\n,\n \nwidthy\n})\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nlayer name: [string], the layer that this rectangle pattern will be embedded. Such layer should already exist in the simulation, otherwise an error message will be printed out.\n\n\nmaterial name: [string],  the material used as the rectangle pattern. Such material should already exist in the simulation, otherwise an error message will be printed out.\n\n\n{centerx, centery}: [double table], the centers of the rectangle pattern in \nx\n and \ny\n direction, respectively, in SI unit.\n\n\n{widthx, widthy}: [double table], the widths of the rectangle pattern in \nx\n and \ny\n direction, respectively, in SI unit.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nSetLayerPatternCircle\n(\nlayer\n \nname\n,\n \nmaterial\n \nname\n,\n \n{\ncenterx\n,\n \ncentery\n},\n \nradius\n)\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nlayer name: [string], the layer that this circle pattern will be embedded. Such layer should already exist in the simulation, otherwise an error message will be printed out.\n\n\nmaterial name: [string],  the material used as the circle pattern. Such material should already exist in the simulation, otherwise an error message will be printed out.\n\n\n{centerx, centery}: [double table], the centers of the circle pattern in \nx\n and \ny\n direction, respectively, in SI unit.\n\n\nradius: [double], the radius of the circle pattern in SI unit.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nSetLayerPatternEllipse\n(\nlayer\n \nname\n,\n \nmaterial\n \nname\n,\n \n{\ncenterx\n,\n \ncentery\n},\n \n{\na\n,\n \nb\n})\n\n\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nlayer name: [string], the layer that this ellipse pattern will be embedded. Such layer should already exist in the simulation, otherwise an error message will be printed out.\n\n\nmaterial name: [string],  the material used as the ellipse pattern. Such material should already exist in the simulation, otherwise an error message will be printed out.\n\n\n{centerx, centery}: [double table], the centers of the ellipse pattern in \nx\n and \ny\n direction, respectively, in SI unit.\n\n\n{a, b}: [double], the half widths the ellipse pattern in SI unit.\n\n\n\n\n\n\n\n\nOutput: None\n\n\n\n\n\n\nNote: the ellipse is written as:\n    \n\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=1", 
            "title": "SimulationPattern"
        }, 
        {
            "location": "/C++API/classAndFunction/", 
            "text": "The C++ interface have the same functions as the Lua interface except for the following changes.\n\n\n\n\nAn instance of a class is initiated to smart pointers. For example to instantiate a \nSimulationPlanar\n object, the right way to do is\n\n\n\n\nPtr\nSimulationPlanar\n \ns\n \n=\n \nSimulationPlanar\n::\ninstanceNew\n();\n\n\n\n\n\n\nThis also applies to the instantiation of \nSimulationGrating\n and \nSimulationPattern\n objects. The advantage of using smart pointers is that there is no need to do manual gabage collection using \ndelete\n.\n\n\n\n\n\n\nFunction names: the function names starts with lower case whereas Lua interface starts with a capital letter.\n\n\n\n\n\n\nextra inputs in function \nsetMaterial\n. In C++, this function is called as    \n\n\n\n\n\n\nvoid\n \nsetMaterial\n(\nconst\n \nstd\n::\nstring\n \nname\n,\n \ndouble\n**\n \nepsilon\n,\n \nconst\n \nstd\n::\nstring\n \ntype\n)\n\n\n\n\n\n\nwhere type is one of \"scalar\", \"diagonal\" and \"tensor\". The 2D array \nepsilon\n then depends on the type. For scalar, the epsilon is of dimension \n\\text{# omega}\\times 2\n. For diagonal, the epsilon is of dimension \n\\text{# omega}\\times 6\n, and for tensor, the epsilon is of dimension \n\\text{# omega}\\times 10\n.\n\n\n\n\n\n\nchanges in obtaining physical constants. In C++ there is no need to initiate or call any function to retrieve the constants. A constant, for example \nq\n, can be directly obtained by using constant.q.\n\n\n\n\n\n\nExtra Makefile is needed. An example for the Makefile for a \nmain.cpp\n file is         \n\n\n\n\n\n\nCFLAGS\n=\n-std\n=\nc++11 -O3 -ffast-math -march\n=\nnative -fopenmp  \n\nMESHPATH\n=\n../../          \n\nINCLUDES\n=\n-I\n$(\nMESHPATH\n)\n/src        \n\nARMAINCLUDE\n=\n-I\n$(\nMESHPATH\n)\n/src/arma -DARMA_DONT_USE_WRAPPER -DARMA_NO_DEBUG         \n\nLIBS\n=\n-L\n$(\nMESHPATH\n)\n/build -lmesh -lopenblas -llapack        \n\nCXX\n=\ng++       \nall:     \n \n$(\nCXX\n)\n \n$(\nCFLAGS\n)\n \n$(\nINCLUDES\n)\n \n${\nARMAINCLUDE\n}\n main.cpp -o main \n$(\nLIBS\n)\n\n\n\n\n\n\nThe \nMESHPATH\n should point to where the \nsrc\n folder is placed.", 
            "title": "Classes and Functions"
        }, 
        {
            "location": "/Examples/tutorial/", 
            "text": "This is an detailed tutorial on the near-field heat transfer between two GaAs slabs backed with PEC.\n\n\n0. Initialize simulation object\n\n\nFirst, to initialize the planar simulation, one should do\n\n\ns\n \n=\n \nSimulationPlanar\n.\nnew\n()\n\n\n\n\n\n\n1. Read input material files\n\n\nFirst, one should add materials to the system, and the materials are initialized by the input files.\n\n\ns\n:\nAddMaterial\n(\nGaAs\n,\n \nGaAs.txt\n)\n\n\ns\n:\nAddMaterial\n(\nPEC\n,\n \nPEC.txt\n)\n\n\ns\n:\nAddMaterial\n(\nVacuum\n,\n \nVacuum.txt\n)\n\n\n\n\n\n\nHere we initialize three materials \nGaAs\n, \nPEC\n and \nVacuum\n, and their dielectric constants are contained in the files \nGaAs.txt\n, \nPEC.txt\n and \nVacuum.txt\n, respectively. Here is a glance at the top few lines of \nGaAs.txt\n file:\n\n\n2.126978e+15    1.306099e+01    1.228760e-02\n2.131253e+15    1.307147e+01    2.845717e-02\n2.135527e+15    1.308195e+01    4.462674e-02\n2.139802e+15    1.309243e+01    6.079631e-02\n2.144077e+15    1.310291e+01    7.696587e-02\n    ...             ...              ...\n\n\n\n\n\nwhere the data is specified in \n\\omega, \\epsilon_r, \\epsilon_i\n fashion, separated by tab, with in total \n199\n rows. All material files should contain the dielectric function at the same omega values. For PEC, one needs to use a very large \n\\epsilon\n value for it be to reflective, and Vacuum needs to have a very small imaginary part (here \n10^{-10}\n) to maintain numerical stability. In addition, make sure that all the \n.txt\n  files are the in the same directory as the \n.lua\n script.\n\n\n2. Add layers to the system\n\n\ns\n:\nAddLayer\n(\nPECBottom\n,\n \n0\n,\n \nPEC\n);\n\n\ns\n:\nAddLayer\n(\nGaAsBottom\n,\n \n1e-6\n,\n \nGaAs\n);\n\n\ns\n:\nAddLayer\n(\nVacGap\n,\n \n1e-8\n,\n \nVacuum\n);\n\n\ns\n:\nAddLayerCopy\n(\nGaAsTop\n,\n \nGaAsBottom\n);\n\n\ns\n:\nAddLayerCopy\n(\nPECTop\n,\n \nPECBottom\n);\n\n\n\n\n\n\nHere there are in total \n5\n layers that has been added to the system: \nPECBottom\n, \nGaAsBottom\n, \nVacGap\n, \nGaAsTop\n and \nPECTop\n. Different from \nS4\n, here the layers are built from bottom to the top, with the bottom most and top most layers being semi-infinite (set thickness to \n0\n here). The following is a drawing illustrating how the layers are added to the system:\n\n\n\n3. Set source and probe, as well as options\n\n\ns\n:\nSetSourceLayer\n(\nGaAsBottom\n);\n\n\ns\n:\nSetProbeLayer\n(\nVacGap\n);\n\n\ns\n:\nOptUseQuadgk\n();\n\n\ns\n:\nSetKParallelIntegral\n(\n10\n);\n\n\ns\n:\nSetThread\n(\n4\n);\n\n\n\n\n\n\nIn this case, since we are simulating the heat transfer between the two GaAs layers, we set the layer \nGaAsBottom\n as the source layer, and \nVacGap\n to be the probe layer where Poynting vector is measured. Here, one needs to ensure that the source layer is always below the probe layer in the system. The following figure is an illustration after the source and probe layers are set.\n\n\n\n4. Build simulation and perform integration\n\n\nNow, with the system built up and the integral set up, one can build RCWA matrices and perform integration over \nk_{\\parallel}\n.\n\n\ns\n:\nInitSimulation\n();\n\n\ns\n:\nIntegrateKParallel\n();\n\n\n\n\n\n\n5. Print results\n\n\nphi\n \n=\n \ns\n:\nGetPhi\n();\n\n\nomega\n \n=\n \ns\n:\nGetOmega\n();\n\n\nfor\n \ni\n \n=\n \n1\n,\ns\n:\nGetNumOfOmega\n(),\n \n1\n \ndo\n\n  \nprint\n(\nstring.format\n(\n%e\n,\n \nomega\n[\ni\n])\n..\n\\t\n..\nstring.format\n(\n%e\n,\n \nphi\n[\ni\n]));\n\n\nend\n\n\n\n\n\n\nThe above is a simple way to retrieve the result and print it to the screen. One can also use Lua built-in i/o functions to output result into files.\n\n\nNow save this file as \nmain.lua\n, and one can simply type\n\n\nmesh main.lua\n\n\n\n\n\nto run the simulation.", 
            "title": "Tutorial Example"
        }, 
        {
            "location": "/Examples/tutorial/#0-initialize-simulation-object", 
            "text": "First, to initialize the planar simulation, one should do  s   =   SimulationPlanar . new ()", 
            "title": "0. Initialize simulation object"
        }, 
        {
            "location": "/Examples/tutorial/#1-read-input-material-files", 
            "text": "First, one should add materials to the system, and the materials are initialized by the input files.  s : AddMaterial ( GaAs ,   GaAs.txt )  s : AddMaterial ( PEC ,   PEC.txt )  s : AddMaterial ( Vacuum ,   Vacuum.txt )   Here we initialize three materials  GaAs ,  PEC  and  Vacuum , and their dielectric constants are contained in the files  GaAs.txt ,  PEC.txt  and  Vacuum.txt , respectively. Here is a glance at the top few lines of  GaAs.txt  file:  2.126978e+15    1.306099e+01    1.228760e-02\n2.131253e+15    1.307147e+01    2.845717e-02\n2.135527e+15    1.308195e+01    4.462674e-02\n2.139802e+15    1.309243e+01    6.079631e-02\n2.144077e+15    1.310291e+01    7.696587e-02\n    ...             ...              ...  where the data is specified in  \\omega, \\epsilon_r, \\epsilon_i  fashion, separated by tab, with in total  199  rows. All material files should contain the dielectric function at the same omega values. For PEC, one needs to use a very large  \\epsilon  value for it be to reflective, and Vacuum needs to have a very small imaginary part (here  10^{-10} ) to maintain numerical stability. In addition, make sure that all the  .txt   files are the in the same directory as the  .lua  script.", 
            "title": "1. Read input material files"
        }, 
        {
            "location": "/Examples/tutorial/#2-add-layers-to-the-system", 
            "text": "s : AddLayer ( PECBottom ,   0 ,   PEC );  s : AddLayer ( GaAsBottom ,   1e-6 ,   GaAs );  s : AddLayer ( VacGap ,   1e-8 ,   Vacuum );  s : AddLayerCopy ( GaAsTop ,   GaAsBottom );  s : AddLayerCopy ( PECTop ,   PECBottom );   Here there are in total  5  layers that has been added to the system:  PECBottom ,  GaAsBottom ,  VacGap ,  GaAsTop  and  PECTop . Different from  S4 , here the layers are built from bottom to the top, with the bottom most and top most layers being semi-infinite (set thickness to  0  here). The following is a drawing illustrating how the layers are added to the system:", 
            "title": "2. Add layers to the system"
        }, 
        {
            "location": "/Examples/tutorial/#3-set-source-and-probe-as-well-as-options", 
            "text": "s : SetSourceLayer ( GaAsBottom );  s : SetProbeLayer ( VacGap );  s : OptUseQuadgk ();  s : SetKParallelIntegral ( 10 );  s : SetThread ( 4 );   In this case, since we are simulating the heat transfer between the two GaAs layers, we set the layer  GaAsBottom  as the source layer, and  VacGap  to be the probe layer where Poynting vector is measured. Here, one needs to ensure that the source layer is always below the probe layer in the system. The following figure is an illustration after the source and probe layers are set.", 
            "title": "3. Set source and probe, as well as options"
        }, 
        {
            "location": "/Examples/tutorial/#4-build-simulation-and-perform-integration", 
            "text": "Now, with the system built up and the integral set up, one can build RCWA matrices and perform integration over  k_{\\parallel} .  s : InitSimulation ();  s : IntegrateKParallel ();", 
            "title": "4. Build simulation and perform integration"
        }, 
        {
            "location": "/Examples/tutorial/#5-print-results", 
            "text": "phi   =   s : GetPhi ();  omega   =   s : GetOmega ();  for   i   =   1 , s : GetNumOfOmega (),   1   do \n   print ( string.format ( %e ,   omega [ i ]) .. \\t .. string.format ( %e ,   phi [ i ]));  end   The above is a simple way to retrieve the result and print it to the screen. One can also use Lua built-in i/o functions to output result into files.  Now save this file as  main.lua , and one can simply type  mesh main.lua  to run the simulation.", 
            "title": "5. Print results"
        }, 
        {
            "location": "/Examples/planeFarField/", 
            "text": "This is a simple example calculating far-field radiation from a \n1~\\mu m\n thick GaAs slab to vacuum. Here one can set the upper bound of \nk_{\\parallel}\n integration to \n1\n because it is far field.\n\n\ns\n \n=\n \nSimulationPlanar\n.\nnew\n()\n\n\ns\n:\nSetThread\n(\n4\n);\n\n\ns\n:\nAddMaterial\n(\nGaAs\n,\n \nGaAs.txt\n);\n\n\ns\n:\nAddMaterial\n(\nVacuum\n,\n \nVacuum.txt\n);\n\n\ns\n:\nAddMaterial\n(\nPEC\n,\n \nPEC.txt\n);\n\n\ns\n:\nAddLayer\n(\nPECLayer\n,\n \n0\n,\n \nPEC\n);\n\n\ns\n:\nAddLayer\n(\nGaAsLayer\n,\n \n1e-6\n,\n \nGaAs\n);\n\n\ns\n:\nAddLayer\n(\nVacuumLayer\n,\n \n0\n,\n \nVacuum\n);\n\n\n\ns\n:\nSetSourceLayer\n(\nGaAsLayer\n);\n\n\ns\n:\nSetProbeLayer\n(\nVacuumLayer\n);\n\n\n\ns\n:\nOptUseQuadgk\n();\n\n\ns\n:\nSetKParallelIntegral\n(\n1\n);\n\n\ns\n:\nInitSimulation\n();\n\n\ns\n:\nIntegrateKParallel\n();\n\n\nphi\n \n=\n \ns\n:\nGetPhi\n();\n\n\nomega\n \n=\n \ns\n:\nGetOmega\n();\n\n\nfor\n \ni\n \n=\n \n1\n,\ns\n:\nGetNumOfOmega\n(),\n \n1\n \ndo\n\n  \nprint\n(\nstring.format\n(\n%e\n,\n \nomega\n[\ni\n])\n..\n\\t\n..\nstring.format\n(\n%e\n,\n \nphi\n[\ni\n]));\n\n\nend", 
            "title": "Single Plane Far-field"
        }, 
        {
            "location": "/Examples/planeNearField/", 
            "text": "This is the complete code for the \ntutorial example\n\n\ns\n \n=\n \nSimulationPlanar\n.\nnew\n()\n\n\ns\n:\nAddMaterial\n(\nGaAs\n,\n \nGaAs.txt\n)\n\n\ns\n:\nAddMaterial\n(\nPEC\n,\n \nPEC.txt\n)\n\n\ns\n:\nAddMaterial\n(\nVacuum\n,\n \nVacuum.txt\n)\n\n\n\ns\n:\nAddLayer\n(\nPECBottom\n,\n \n0\n,\n \nPEC\n);\n\n\ns\n:\nAddLayer\n(\nGaAsBottom\n,\n \n1e-6\n,\n \nGaAs\n);\n\n\ns\n:\nAddLayer\n(\nVacGap\n,\n \n1e-8\n,\n \nVacuum\n);\n\n\ns\n:\nAddLayerCopy\n(\nGaAsTop\n,\n \nGaAsBottom\n);\n\n\ns\n:\nAddLayerCopy\n(\nPECTop\n,\n \nPECBottom\n);\n\n\n\ns\n:\nSetSourceLayer\n(\nGaAsBottom\n);\n\n\ns\n:\nSetProbeLayer\n(\nVacGap\n);\n\n\ns\n:\nOptUseQuadgk\n();\n\n\ns\n:\nSetKParallelIntegral\n(\n10\n);\n\n\ns\n:\nSetThread\n(\n4\n);\n\n\n\ns\n:\nInitSimulation\n();\n\n\ns\n:\nIntegrateKParallel\n();\n\n\n\nphi\n \n=\n \ns\n:\nGetPhi\n();\n\n\nomega\n \n=\n \ns\n:\nGetOmega\n();\n\n\nfor\n \ni\n \n=\n \n1\n,\ns\n:\nGetNumOfOmega\n(),\n \n1\n \ndo\n\n  \nprint\n(\nstring.format\n(\n%e\n,\n \nomega\n[\ni\n])\n..\n\\t\n..\nstring.format\n(\n%e\n,\n \nphi\n[\ni\n]));\n\n\nend\n\n\n\n\n\n\nThis code can be run by:\n\n\nmesh main.lua \n output.txt\n\n\n\n\n\nand the results will be contained in the \noutput.txt\n file.", 
            "title": "Two Planes Near-field"
        }, 
        {
            "location": "/Examples/anisotropic/", 
            "text": "This is an example that has been used in the paper \nPhys. Rev. Applied 6, 024014, 2016\n, where \nhBN\n has a diagonal dielectric function as (top \n5\n rows)\n\n\n2.127000e+14    1.022020e+01    3.983602e-01    1.022020e+01    3.983602e-01    4.251609e+00    3.151862e-01\n2.128640e+14    1.023858e+01    3.932224e-01    1.023858e+01    3.932224e-01    4.248610e+00    3.151862e-01\n2.130281e+14    1.025696e+01    3.880846e-01    1.025696e+01    3.880846e-01    4.253492e+00    3.151862e-01\n2.131921e+14    1.027534e+01    3.829468e-01    1.027534e+01    3.829468e-01    4.258538e+00    3.151862e-01\n2.133561e+14    1.029372e+01    3.778090e-01    1.029372e+01    3.778090e-01    4.263583e+00    3.151862e-01\n\n\n\n\n\nThese values correspond to \n\\omega, \\text{real}(\\epsilon_{xx}), \\text{imag}(\\epsilon_{xx}), \\text{real}(\\epsilon_{yy}), \\text{imag}(\\epsilon_{yy}), \\text{real}(\\epsilon_{zz}), \\text{imag}(\\epsilon_{zz})\n, respectively. And the following is a script computing the flux between MCT and hBN in the presence of a \n10~\\text{nm}\n vacuum gap.\n\n\ns\n \n=\n \nSimulationPlanar\n.\nnew\n()\n\n\ns\n:\nAddMaterial\n(\nhBN\n,\n \nhBN.txt\n)\n\n\ns\n:\nAddMaterial\n(\nMCT\n,\n \nMCT.txt\n)\n\n\ns\n:\nAddMaterial\n(\nPEC\n,\n \nPEC.txt\n)\n\n\ns\n:\nAddMaterial\n(\nVacuum\n,\n \nVacuum.txt\n)\n\n\n\ns\n:\nAddLayer\n(\nPECBottom\n,\n \n0\n,\n \nPEC\n);\n\n\ns\n:\nAddLayer\n(\nhBNLayer\n,\n \n5e-6\n,\n \nhBN\n);\n\n\ns\n:\nAddLayer\n(\nVacLayer\n,\n \n1e-8\n,\n \nVacuum\n);\n\n\ns\n:\nAddLayer\n(\nMCTLayer\n,\n \n5e-6\n,\n \nMCT\n);\n\n\ns\n:\nAddLayerCopy\n(\nPECTop\n,\n \nPECBottom\n);\n\n\n\ns\n:\nSetSourceLayer\n(\nhBNLayer\n);\n\n\ns\n:\nSetProbeLayer\n(\nVacLayer\n);\n\n\n\ns\n:\nSetKParallelIntegral\n(\n100\n);\n\n\ns\n:\nSetThread\n(\n4\n);\n\n\ns\n:\nOptUseQuadgk\n();\n\n\ns\n:\nInitSimulation\n();\n\n\ns\n:\nIntegrateKParallel\n();\n\n\nphi\n \n=\n \ns\n:\nGetPhi\n();\n\n\nomega\n \n=\n \ns\n:\nGetOmega\n();\n\n\nfor\n \ni\n \n=\n \n1\n,\ns\n:\nGetNumOfOmega\n(),\n \n1\n \ndo\n\n  \nprint\n(\nstring.format\n(\n%e\n,\n \nomega\n[\ni\n])\n..\n\\t\n..\nstring.format\n(\n%e\n,\n \nphi\n[\ni\n]));\n\n\nend\n\n\n\n\n\n\nThe output of the Lua file is the same as the output from the original MATLAB code. The output from the MATLAB code is \nElectron_5000_10_5000.mat\n.", 
            "title": "Anisotropic Material Near-field"
        }, 
        {
            "location": "/Examples/iterate/", 
            "text": "This file is similar to the \nTwo Planes Near-field\n example, except for a loop over the vacuum gap separations.\n\n\ns\n \n=\n \nSimulationPlanar\n.\nnew\n()\n\n\ns\n:\nAddMaterial\n(\nGaAs\n,\n \nGaAs.txt\n);\n\n\ns\n:\nAddMaterial\n(\nVacuum\n,\n \nVacuum.txt\n);\n\n\ns\n:\nAddMaterial\n(\nPEC\n,\n \nPEC.txt\n);\n\n\n\ns\n:\nAddLayer\n(\nPECBottom\n,\n \n0\n,\n \nPEC\n);\n\n\ns\n:\nAddLayer\n(\nGaAsBottom\n,\n \n1e-6\n,\n \nGaAs\n);\n\n\ns\n:\nAddLayer\n(\nVacGap\n,\n \n1e-8\n,\n \nVacuum\n);\n\n\ns\n:\nAddLayerCopy\n(\nGaAsTop\n,\n \nGaAsBottom\n);\n\n\ns\n:\nAddLayerCopy\n(\nPECTop\n,\n \nPECBottom\n);\n\n\n\n\ns\n:\nSetSourceLayer\n(\nGaAsBottom\n);\n\n\ns\n:\nSetProbeLayer\n(\nVacGap\n);\n\n\ns\n:\nOptUseQuadgk\n();\n\n\ns\n:\nSetThread\n(\n4\n);\n\n\ns\n:\nSetKParallelIntegral\n(\n500\n);\n\n\n\nfor\n \ni\n \n=\n \n10\n,\n \n100\n,\n \n10\n \ndo\n\n  \ns\n:\nSetLayerThickness\n(\nVacGap\n,\n \ni\n \n*\n \n1e-9\n);\n\n  \ns\n:\nInitSimulation\n();\n\n  \ns\n:\nIntegrateKParallel\n();\n\n  \nphi\n \n=\n \ns\n:\nGetPhi\n();\n\n  \nomega\n \n=\n \ns\n:\nGetOmega\n();\n\n  \nfor\n \nj\n \n=\n \n1\n,\ns\n:\nGetNumOfOmega\n(),\n \n1\n \ndo\n\n    \nprint\n(\nstring.format\n(\n%e\n,\n \nomega\n[\nj\n])\n..\n\\t\n..\nstring.format\n(\n%e\n,\n \nphi\n[\nj\n]));\n\n  \nend\n\n\nend\n\n\n\n\n\n\nOne can use the same way described here in one's own simulation for a scan of thickness of layers.", 
            "title": "Iterate Over Gaps Near-field"
        }, 
        {
            "location": "/Examples/gratingNearField/", 
            "text": "This code can produce the result in Fig. 3 (a) red curve in \nPhys. Rev. B 93, 155403, 2016\n.\n\n\ns\n \n=\n \nSimulationGrating\n.\nnew\n()\n\n\ns\n:\nSetPeriodicity\n(\n1e-6\n);\n\n\ns\n:\nAddMaterial\n(\nAu\n,\n \nfullGold.txt\n);\n\n\ns\n:\nAddMaterial\n(\nVacuum\n,\n \nfullVacuum.txt\n);\n\n\n\ns\n:\nAddLayer\n(\nBottomAir\n,\n \n0\n,\n \nVacuum\n);\n\n\ns\n:\nAddLayer\n(\nGoldSubstrateBottom\n,\n \n0.5e-6\n,\n \nAu\n);\n\n\ns\n:\nAddLayer\n(\nGoldGratingBottom\n,\n \n5e-6\n,\nAu\n);\n\n\ns\n:\nSetLayerPatternGrating\n(\nGoldGratingBottom\n,\n \nVacuum\n,\n \n0.5e-6\n,\n \n0.2e-6\n);\n\n\n\ns\n:\nAddLayer\n(\nVacGap\n,\n \n1e-6\n,\n \nVacuum\n);\n\n\ns\n:\nAddLayerCopy\n(\nGoldGratingTop\n,\n \nGoldGratingBottom\n);\n\n\ns\n:\nAddLayerCopy\n(\nGoldSubstrateTop\n,\n \nGoldSubstrateBottom\n);\n\n\ns\n:\nAddLayerCopy\n(\nTopAir\n,\n \nBottomAir\n);\n\n\n\ns\n:\nSetSourceLayer\n(\nGoldSubstrateBottom\n);\n\n\ns\n:\nSetSourceLayer\n(\nGoldGratingBottom\n);\n\n\ns\n:\nSetProbeLayer\n(\nVacGap\n);\n\n\ns\n:\nOutputSysInfo\n();\n\n\n\ns\n:\nOptPrintIntermediate\n();\n\n\ns\n:\nSetThread\n(\n4\n);\n\n\ns\n:\nSetGx\n(\n50\n);\n\n\ns\n:\nSetKxIntegralSym\n(\n500\n);\n\n\ns\n:\nSetKyIntegralSym\n(\n200\n,\n \n5\n);\n\n\ns\n:\nInitSimulation\n();\n\n\ns\n:\nIntegrateKxKy\n();\n\n\n--print(string.format(\n%e\n, s:GetPhiAtKxKy(0, 0, 0)));\n\n\nphi\n \n=\n \ns\n:\nGetPhi\n();\n\n\nomega\n \n=\n \ns\n:\nGetOmega\n();\n\n\nfor\n \ni\n \n=\n \n1\n,\ns\n:\nGetNumOfOmega\n(),\n \n1\n \ndo\n\n  \nprint\n(\nstring.format\n(\n%e\n,\n \nomega\n[\ni\n])\n..\n\\t\n..\nstring.format\n(\n%e\n,\n \nphi\n[\ni\n]));\n\n\nend\n\n\n\n\n\n\nThe curve produced by this code is", 
            "title": "Two Gratings Near-field"
        }, 
        {
            "location": "/Examples/rectangleNearField/", 
            "text": "This is an example for Fig.2 (b) black curve in \narXiv:1701.02986\n.\n\n\nconstants\n \n=\n \nConstants\n();\n\n\n\nfunction\n \nthetaDerivative\n(\nomega\n,\n \nT\n)\n\n  \nlocal\n \ntheta\n \n=\n \nconstants\n.\nh_bar\n \n*\n \nomega\n \n/\n \n(\nmath.exp\n(\nconstants\n.\nh_bar\n \n*\n \nomega\n/\nconstants\n.\nk_B\n/\nT\n)\n \n-\n \n1\n);\n\n  \nreturn\n \nmath.pow\n(\ntheta\n,\n \n2\n)\n \n*\n \nmath.exp\n(\nconstants\n.\nh_bar\n \n*\n \nomega\n/\nconstants\n.\nk_B\n/\nT\n)\n \n/\nconstants\n.\nk_B\n \n/\n \nmath.pow\n(\nT\n,\n \n2\n);\n\n\nend\n\n\n\nf\n \n=\n \n0.98\n;\n\n\nwidth\n \n=\n \nmath.sqrt\n(\nf\n \n*\n \n50e-9\n \n*\n \n50e-9\n);\n\n\ns\n \n=\n \nSimulationPattern\n.\nnew\n();\n\n\ns\n:\nSetPeriodicity\n(\n50e-9\n,\n \n50e-9\n);\n\n\ns\n:\nSetGx\n(\n10\n);\n\n\ns\n:\nSetGy\n(\n10\n);\n\n\n\ns\n:\nAddMaterial\n(\nSi\n,\n \nSi.txt\n);\n\n\ns\n:\nAddMaterial\n(\nVacuum\n,\n \nVacuum.txt\n);\n\n\ns\n:\nAddLayer\n(\nSiBottom\n,\n \n0\n,\n \nSi\n);\n\n\ns\n:\nSetLayerPatternRectangle\n(\nSiBottom\n,\n \nVacuum\n,\n \n{\n25e-9\n,\n \n25e-9\n},\n \n{\nwidth\n,\n \nwidth\n});\n\n\ns\n:\nAddLayer\n(\nVacGap\n,\n \n20e-9\n,\n \nVacuum\n);\n\n\ns\n:\nAddLayerCopy\n(\nSiTop\n,\n \nSiBottom\n);\n\n\n\ns\n:\nSetSourceLayer\n(\nSiBottom\n);\n\n\ns\n:\nSetProbeLayer\n(\nVacGap\n);\n\n\ns\n:\nOutputSysInfo\n();\n\n\n\ns\n:\nOptPrintIntermediate\n();\n\n\ns\n:\nSetKxIntegralSym\n(\n20\n,\n \n60\n);\n\n\ns\n:\nSetKyIntegralSym\n(\n20\n,\n \n60\n);\n\n\ns\n:\nInitSimulation\n();\n\n\ns\n:\nIntegrateKxKy\n();\n\n\n\nphi\n \n=\n \ns\n:\nGetPhi\n();\n\n\nomega\n \n=\n \ns\n:\nGetOmega\n();\n\n\nfor\n \ni\n \n=\n \n1\n,\ns\n:\nGetNumOfOmega\n(),\n \n1\n \ndo\n\n  \nprint\n(\nstring.format\n(\n%e\n,\n \nomega\n[\ni\n])\n..\n\\t\n..\nstring.format\n(\n%e\n,\n \nphi\n[\ni\n]));\n\n\nend\n\n\n\n\n\n\n// TODO: test", 
            "title": "Two Rectangle Patterns Near-field"
        }, 
        {
            "location": "/Examples/mixedNearField/", 
            "text": "The following is an example with a mixed pattern on one layer. The layer \nSiTop\n has two patterns: (1) a rectangle patten centered at (250 nm, 250 nm) with widths (300 nm, 300 nm), and (2) a circle pattern centered at (750 nm, 750 nm) with radius 200 nm. Note that MESH has a contraint that patterns cannot interleave with each other.\n\n\ns\n \n=\n \nSimulationPattern\n.\nnew\n();\n\n\ns\n:\nSetPeriodicity\n(\n1e-6\n,\n \n1e-6\n);\n\n\ns\n:\nSetGx\n(\n12\n);\n\n\ns\n:\nSetGy\n(\n12\n);\n\n\n\ns\n:\nAddMaterial\n(\nSi\n,\n \nSi.txt\n);\n\n\ns\n:\nAddMaterial\n(\nVacuum\n,\n \nVacuum.txt\n);\n\n\n\ns\n:\nAddLayer\n(\nSiBottom\n,\n \n0\n,\n \nSi\n);\n\n\ns\n:\nAddLayer\n(\nVacGap\n,\n \n1e-6\n,\n \nVacuum\n);\n\n\ns\n:\nAddLayer\n(\nSiTop\n,\n \n0\n,\n \nSi\n);\n\n\ns\n:\nSetLayerPatternRectangle\n(\nSiTop\n,\n \nVacuum\n,\n \n{\n2.5e-7\n,\n \n2.5e-7\n},\n \n{\n3e-7\n,\n \n3e-7\n});\n\n\ns\n:\nSetLayerPatternCircle\n(\nSiTop\n,\n \nVacuum\n,\n \n{\n7.5e-7\n,\n \n7.5e-7\n},\n \n2e-7\n);\n\n\n\n\ns\n:\nSetSourceLayer\n(\nSiBottom\n);\n\n\ns\n:\nSetProbeLayer\n(\nVacGap\n);\n\n\ns\n:\nOutputSysInfo\n();\n\n\n\ns\n:\nOptPrintIntermediate\n();\n\n\ns\n:\nSetKxIntegralSym\n(\n20\n,\n \n60\n);\n\n\ns\n:\nSetKyIntegralSym\n(\n20\n,\n \n60\n);\n\n\ns\n:\nInitSimulation\n();\n\n\ns\n:\nIntegrateKxKy\n();", 
            "title": "Mixed Patterns Near-field"
        }, 
        {
            "location": "/Examples/MPI/", 
            "text": "This is an MPI example, rewriting the same example in \nTwo Gratings Near-field\n\n\ns\n \n=\n \nSimulationGrating\n.\nnew\n();\n\n\ns\n:\nSetPeriodicity\n(\n1e-6\n);\n\n\ns\n:\nAddMaterial\n(\nAu\n,\n \nfullGold.txt\n);\n\n\ns\n:\nAddMaterial\n(\nVacuum\n,\n \nfullVacuum.txt\n);\n\n\n\ns\n:\nAddLayer\n(\nBottomAir\n,\n \n0\n,\n \nVacuum\n);\n\n\ns\n:\nAddLayer\n(\nGoldSubstrateBottom\n,\n \n0.5e-6\n,\n \nAu\n);\n\n\ns\n:\nAddLayer\n(\nGoldGratingBottom\n,\n \n5e-6\n,\nAu\n);\n\n\ns\n:\nSetLayerPatternGrating\n(\nGoldGratingBottom\n,\n \nVacuum\n,\n \n0.5e-6\n,\n \n0.2e-6\n);\n\n\n\ns\n:\nAddLayer\n(\nVacGap\n,\n \n1e-6\n,\n \nVacuum\n);\n\n\ns\n:\nAddLayerCopy\n(\nGoldGratingTop\n,\n \nGoldGratingBottom\n);\n\n\ns\n:\nAddLayerCopy\n(\nGoldSubstrateTop\n,\n \nGoldSubstrateBottom\n);\n\n\ns\n:\nAddLayerCopy\n(\nTopAir\n,\n \nBottomAir\n);\n\n\n\ns\n:\nSetSourceLayer\n(\nGoldSubstrateBottom\n);\n\n\ns\n:\nSetSourceLayer\n(\nGoldGratingBottom\n);\n\n\ns\n:\nSetProbeLayer\n(\nVacGap\n);\n\n\n\ns\n:\nOptPrintIntermediate\n();\n\n\ns\n:\nSetGx\n(\n50\n);\n\n\ns\n:\nSetKxIntegralSym\n(\n500\n);\n\n\ns\n:\nSetKyIntegralSym\n(\n200\n,\n \n5\n);\n\n\ns\n:\nInitSimulation\n();\n\n\n\n\n\n\nThe above are the same as the standard Lua script. The following code configures the MPI.\n\n\n----------------------------------------------------------------\n\n\n-- this part is for MPI\n\n\n-- in principle there is no need to change this part for your simulation\n\n\n----------------------------------------------------------------\n\n\n-- start MPI\n\n\nlocal\n \nsizeb\n \n=\n \nbuffer\n.\nnew_buffer\n(\nbuffer\n.\nsizeof\n(\nbuffer\n.\nint\n))\n\n\nlocal\n \nrankb\n \n=\n \nbuffer\n.\nnew_buffer\n(\nbuffer\n.\nsizeof\n(\nbuffer\n.\nint\n))\n\n\n\nMPI\n.\nInit\n()\n\n\nMPI\n.\nComm_rank\n(\nMPI\n.\nCOMM_WORLD\n,\n \nrankb\n)\n\n\nMPI\n.\nComm_size\n(\nMPI\n.\nCOMM_WORLD\n,\n \nsizeb\n)\n\n\n\nlocal\n \nsize\n \n=\n \nbuffer\n.\nget_typed\n(\nsizeb\n,\n \nbuffer\n.\nint\n,\n \n0\n)\n\n\nlocal\n \nrank\n \n=\n \nbuffer\n.\nget_typed\n(\nrankb\n,\n \nbuffer\n.\nint\n,\n \n0\n)\n\n\n\nif\n \nrank\n \n==\n \n0\n \nthen\n\n  \ns\n:\nOutputSysInfo\n();\n\n\nend\n\n\n\nstatus\n \n=\n \nMPI\n.\nStatus\n()\n\n\nnumOfOmega\n \n=\n \ns\n:\nGetNumOfOmega\n()\n\n\nomega\n \n=\n \ns\n:\nGetOmega\n();\n\n\n-- rank 0 is the master node\n\n\nif\n \nrank\n \n==\n \n0\n \nthen\n\n  \ns\n:\nIntegrateKxKyMPI\n(\nrank\n,\n \nsize\n);\n\n  \nphi_master\n \n=\n \ns\n:\nGetPhi\n();\n\n  \n-- master collects values from slave\n\n  \nfor\n \ni\n \n=\n \n1\n,\nsize\n \n-\n \n1\n \ndo\n\n    \nlocal\n \nphi_local\n \n=\n \nbuffer\n.\nnew_buffer\n(\nnumOfOmega\n \n*\n \nbuffer\n.\nsizeof\n(\nbuffer\n.\ndouble\n));\n\n    \nMPI\n.\nRecv\n(\nphi_local\n,\n \nnumOfOmega\n,\n \nMPI\n.\nDOUBLE\n,\n \ni\n,\n \n0\n,\n \nMPI\n.\nCOMM_WORLD\n,\n \nstatus\n);\n\n    \nfor\n \nj\n \n=\n \n1\n,\n \nnumOfOmega\n \ndo\n\n      \nphi_master\n[\nj\n]\n \n=\n \nphi_master\n[\nj\n]\n \n+\n \nbuffer\n.\nget_typed\n(\nphi_local\n,\n \nbuffer\n.\ndouble\n,\n \nj\n \n-\n \n1\n);\n\n    \nend\n\n  \nend\n\n  \n-- output all the phi values from the master\n\n  \nfor\n \ni\n \n=\n \n1\n,\nnumOfOmega\n \ndo\n\n    \nprint\n(\nstring.format\n(\n%e\n,\n \nomega\n[\ni\n])\n..\n\\t\n..\nstring.format\n(\n%e\n,\n \nphi_master\n[\ni\n]));\n\n  \nend\n\n\n-- rank 1-size are the slave nodes\n\n\nelse\n\n  \ns\n:\nIntegrateKxKyMPI\n(\nrank\n,\n \nsize\n);\n\n  \nlocal\n \nphi_slave\n \n=\n \ns\n:\nGetPhi\n();\n\n  \n-- slave nodes send phi values back to master\n\n  \nlocal\n \nphi_\n \n=\n \nbuffer\n.\nnew_buffer\n(\nnumOfOmega\n \n*\n \nbuffer\n.\nsizeof\n(\nbuffer\n.\ndouble\n));\n\n  \nfor\n \ni\n \n=\n \n1\n,\n \nnumOfOmega\n \ndo\n\n    \nbuffer\n.\nset_typed\n(\nphi_\n,\n \nbuffer\n.\ndouble\n,\n \ni\n \n-\n \n1\n,\n \nphi_slave\n[\ni\n]);\n\n  \nend\n\n  \nMPI\n.\nSend\n(\nphi_\n,\n \nnumOfOmega\n,\n \nMPI\n.\nDOUBLE\n,\n \n0\n,\n \n0\n,\n \nMPI\n.\nCOMM_WORLD\n);\n\n\nend\n\n\n\nMPI\n.\nFinalize\n();\n\n\n\n\n\n\nThe above code uses master-slave manner, where rank \n0\n is the master node that collects all the \n\\Phi(\\omega)\n from the other slave nodes, and then sum them together. The code can be run by:\n\n\nmpirun -np \n40\n meshMPI main.lua", 
            "title": "MPI Example"
        }, 
        {
            "location": "/develop/", 
            "text": "The source code of MESH is in \nsrc/\n folder, which consists of the following files and folders:\n\n\n\n\narma/\n: the folder contains all the headers from \narmadillo\n.\n\n\nluawrapper/\n: the Lua wrapper for C++ classes and MPI.\n\n\nmathlib/\n: some mathematical functions such as Bessel functions, and Gauss-legendre integral method.\n\n\nutility/\n: templates for smart points as well as exception handling.\n\n\nCubature.c\n: a fast adaptive integration method for high dimensional functions, adoptted from \nthe original code\n.\n\n\nFmm.cpp\n: file computing the Fourier transform for different geometries.\n\n\nRcwa.cpp\n: file computing the RCWA and Poynting vector.\n\n\nSystem.cpp\n: file containing material, layer and structure classes and their methods.\n\n\nMesh.cpp\n: file containing different types of simulations and C++ API.\n\n\nmain_lua.cpp\n: file implementing Lua API.\n\n\n\n\nThe class structure is illustrated in the following figure\n\n\n\n\nThere are few features that need to be implemented in MESH:\n\n\n\n\nA correct and fast implementation of Fourier transform over dielectric functions.\n\n\nImproved ways of doing \nk_x\n and \nk_y\n integral other than the current naive summation method.\n\n\nComputing more physical quantities, such as energy density and Casimir force.", 
            "title": "Developer"
        }, 
        {
            "location": "/about/", 
            "text": "MESH is copyright (c) 2016-2018, Stanford University.\n\n\nMESH is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\n\nYou should have received a copy of the GNU General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. You can also find it on the GNU web site:\n\n\nhttp://www.gnu.org/copyleft/gpl.html\n\n\nThe author would like to acknowledge the following packages:\n\n\n\n\n\n\narmadillo: \nC++ linear algebra library\n\n\n\n\n\n\nluawrapper: \nThe lua wrapper for C++ classes\n\n\n\n\n\n\nlua-mpi: \nThe lua wrapper for MPI\n\n\n\n\n\n\nAlso, the author would like to thank \nDr. Bo Zhao\n, \nYu Guo\n and alumni \nDr. Linxiao Zhu\n, \nDr. Victor Liu\n for useful discussions, and Siddharth Buddhiraju for testing installation and some cases.", 
            "title": "About"
        }
    ]
}